import { useState } from "react";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogTrigger } from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Download, Upload, FileText, AlertCircle, CheckCircle, XCircle } from "lucide-react";
import { Separator } from "@/components/ui/separator";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { useToast } from "@/hooks/use-toast";
import { ButtonLoader } from "@/components/ui/loader";
import Papa from "papaparse";
import { apiRequest } from "@/lib/queryClient";
import type { InsertLead } from "@shared/schema";

interface ImportDialogProps {
  onImportSuccess?: () => void;
}

export default function ImportDialog({ onImportSuccess }: ImportDialogProps) {
  const [isOpen, setIsOpen] = useState(false);
  const [isImporting, setIsImporting] = useState(false);
  const [importResults, setImportResults] = useState<any>(null);
  const { toast } = useToast();

  const handleDownloadTemplate = () => {
    // Create CSV template with all lead form attributes
    const csvHeaders = [
      "Name*",
      "Phone Number*",
      "Email",
      "Date of Birth (YYYY-MM-DD)",
      "City",
      "State",
      "Country",
      "Pincode/Zipcode",
      "Company Name",
      "Designation",
      "Customer Category* (existing/potential)",
      "Last Contacted Date (YYYY-MM-DD)",
      "Last Contacted By",
      "Next Followup Date (YYYY-MM-DD)",
      "Customer Interested In",
      "Preferred Communication Channel (email/phone/whatsapp/sms/in-person/linkedin/other)",
      "Custom Communication Channel (if other selected)",
      "Lead Source* (website/referral/linkedin/facebook/twitter/instagram/campaign/generated_by/on_field/other)",
      "Custom Lead Source (if other selected)",
      "Custom Referral Source (if referral selected)",
      "Custom Generated By (if generated_by selected)",
      "Lead Status* (new/followup/qualified/hot/converted/lost)",
      "Lead Created By",
      "Additional Notes"
    ];

    // Create CSV content with headers only
    const csvContent = csvHeaders.join(",");

    // Create and download file
    const blob = new Blob([csvContent], { type: 'text/csv' });
    const url = window.URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = 'leads_import_template.csv';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    window.URL.revokeObjectURL(url);
  };

  const handleUploadFile = () => {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.csv,.xlsx,.xls';
    input.onchange = async (e) => {
      const file = (e.target as HTMLInputElement).files?.[0];
      if (file) {
        await processCSVFile(file);
      }
    };
    input.click();
  };

  const processCSVFile = async (file: File) => {
    try {
      setIsImporting(true);
      setImportResults(null);

      // Show initial progress
      toast({
        title: "Processing File",
        description: "Reading and parsing CSV file...",
      });

      // Read the file
      const text = await file.text();
      
      // Parse CSV
      console.log("Raw CSV text:", text);
      Papa.parse(text, {
        header: true,
        skipEmptyLines: true,
        delimiter: text.includes('\t') ? '\t' : ',', // Handle both tab and comma delimiters
        complete: async (results) => {
          console.log("CSV parsing results:", results);
          try {
            const leads = results.data as any[];
            
            if (leads.length === 0) {
              toast({
                title: "No Data Found",
                description: "The CSV file appears to be empty or has no valid data.",
                variant: "destructive",
              });
              return;
            }

            // Show transformation progress
            toast({
              title: "Transforming Data",
              description: `Processing ${leads.length} rows...`,
            });

            // Transform CSV data to match our schema (optimized)
            const transformedLeads = leads
              .map((row, index) => {
                try {
                  return transformCSVRowToLead(row, index + 1);
                } catch (error) {
                  console.error(`Error transforming row ${index + 1}:`, error);
                  return null;
                }
              })
              .filter(lead => lead !== null) as InsertLead[]; // Filter out any null leads

            if (transformedLeads.length === 0) {
              toast({
                title: "No Valid Data",
                description: "No valid leads found in the CSV file.",
                variant: "destructive",
              });
              return;
            }

            // Show import progress
            toast({
              title: "Importing Leads",
              description: `Sending ${transformedLeads.length} leads to server...`,
            });

            // Send to backend (optimized endpoint)
            const response = await apiRequest("POST", "/api/leads/import", {
              leads: transformedLeads
            });

            const result = await response.json();
            console.log("Import result:", result);
            setImportResults(result);

            if (result.results.successful > 0) {
              toast({
                title: "Import Successful",
                description: `${result.results.successful} leads imported successfully from ${leads.length} rows in CSV.`,
              });

              // Call success callback if provided
              if (onImportSuccess) {
                console.log("Calling onImportSuccess callback");
                onImportSuccess();
              }
            }

            if (result.results.failed > 0) {
              toast({
                title: "Import Completed",
                description: `${result.results.successful} leads imported, ${result.results.failed} rows skipped.`,
              });
            }

          } catch (error) {
            console.error("Error processing CSV:", error);
            toast({
              title: "Import Error",
              description: "Failed to process the CSV file. Please check the file format and try again.",
              variant: "destructive",
            });
          } finally {
            setIsImporting(false);
          }
        },
        error: (error: any) => {
          console.error("CSV parsing error:", error);
          toast({
            title: "CSV Parsing Error",
            description: "Failed to parse the CSV file. Please check the file format.",
            variant: "destructive",
          });
          setIsImporting(false);
        }
      });

    } catch (error) {
      console.error("Error reading file:", error);
      toast({
        title: "File Read Error",
        description: "Failed to read the uploaded file.",
        variant: "destructive",
      });
      setIsImporting(false);
    }
  };

  const transformCSVRowToLead = (row: any, rowNumber: number): InsertLead => {
    // Helper function to clean data
    const cleanValue = (value: any) => {
      if (value === undefined || value === null || value === '') return undefined;
      return String(value).trim();
    };

    // Helper function to get field value with fallbacks
    const getFieldValue = (row: any, possibleNames: string[]) => {
      console.log(`Looking for field with possible names:`, possibleNames);
      console.log(`Available fields in row:`, Object.keys(row));
      for (const name of possibleNames) {
        if (row[name] !== undefined && row[name] !== null && row[name] !== '') {
          console.log(`Found field "${name}" with value:`, row[name]);
          return row[name];
        }
      }
      console.log(`No field found for names:`, possibleNames);
      return undefined;
    };

    // Helper function to validate enum with fallback to default
    const validateEnum = (value: any, allowedValues: string[], defaultValue: string) => {
      if (!value) return defaultValue;
      const lowerValue = value.toLowerCase();
      if (allowedValues.includes(lowerValue)) {
        return lowerValue;
      }
      return defaultValue;
    };

    // Helper function to validate date with fallback
    const validateDate = (value: any) => {
      if (!value) return undefined;
      const date = new Date(value);
      if (isNaN(date.getTime())) {
        return undefined; // Return undefined instead of throwing error
      }
      return value;
    };

    // Helper function to validate phone with fallback
    const validatePhone = (value: any) => {
      if (!value) return "N/A"; // Default value instead of error
      return value;
    };

    // Helper function to validate email with fallback
    const validateEmail = (value: any) => {
      if (!value) return undefined;
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      if (!emailRegex.test(value)) {
        return undefined; // Return undefined instead of throwing error
      }
      return value;
    };

    try {
      return {
        name: cleanValue(getFieldValue(row, ["Name*", "Name", "name"])) || `Lead ${rowNumber}`,
        phoneNumber: validatePhone(cleanValue(getFieldValue(row, ["Phone Number*", "Phone Number", "PhoneNumber", "phoneNumber"]))),
        email: validateEmail(cleanValue(row.Email || row.email)),
        dateOfBirth: validateDate(cleanValue(row["Date of Birth (YYYY-MM-DD)"] || row["Date of Birth"] || row["DateOfBirth"] || row.dateOfBirth)),
        city: cleanValue(row.City || row.city),
        state: cleanValue(row.State || row.state),
        country: cleanValue(row.Country || row.country),
        pincode: cleanValue(row["Pincode/Zipcode"] || row.Pincode || row.pincode),
        companyName: cleanValue(row["Company Name"] || row["CompanyName"] || row.companyName),
        designation: cleanValue(row.Designation || row.designation),
        customerCategory: validateEnum(
          cleanValue(getFieldValue(row, ["Customer Category* (existing/potential)", "Customer Category", "CustomerCategory", "customerCategory"])),
          ["existing", "potential"],
          "potential"
        ) as "existing" | "potential",
        lastContactedDate: validateDate(cleanValue(row["Last Contacted Date (YYYY-MM-DD)"] || row["Last Contacted Date"] || row["LastContactedDate"] || row.lastContactedDate)),
        lastContactedBy: cleanValue(row["Last Contacted By"] || row["LastContactedBy"] || row.lastContactedBy),
        nextFollowupDate: validateDate(cleanValue(row["Next Followup Date (YYYY-MM-DD)"] || row["Next Followup Date"] || row["NextFollowupDate"] || row.nextFollowupDate)),
        customerInterestedIn: cleanValue(row["Customer Interested In"] || row["CustomerInterestedIn"] || row.customerInterestedIn),
        preferredCommunicationChannel: validateEnum(
          cleanValue(row["Preferred Communication Channel (email/phone/whatsapp/sms/in-person/linkedin/other)"] || row["Preferred Communication Channel"] || row["PreferredCommunicationChannel"] || row.preferredCommunicationChannel),
          ["email", "phone", "whatsapp", "sms", "in-person", "linkedin", "other"],
          "email"
        ) as any,
        customCommunicationChannel: cleanValue(row["Custom Communication Channel (if other selected)"] || row["Custom Communication Channel"] || row["CustomCommunicationChannel"] || row.customCommunicationChannel),
        leadSource: validateEnum(
          cleanValue(getFieldValue(row, ["Lead Source* (website/referral/linkedin/facebook/twitter/instagram/campaign/generated_by/on_field/other)", "Lead Source", "LeadSource", "leadSource"])),
          ["website", "referral", "linkedin", "facebook", "twitter", "campaign", "instagram", "generated_by", "on_field", "other"],
          "website"
        ) as any,
        customLeadSource: cleanValue(row["Custom Lead Source (if other selected)"] || row["Custom Lead Source"] || row["CustomLeadSource"] || row.customLeadSource),
        customReferralSource: cleanValue(row["Custom Referral Source (if referral selected)"] || row["Custom Referral Source"] || row["CustomReferralSource"] || row.customReferralSource),
        customGeneratedBy: cleanValue(row["Custom Generated By (if generated_by selected)"] || row["Custom Generated By"] || row["CustomGeneratedBy"] || row.customGeneratedBy),
        leadStatus: validateEnum(
          cleanValue(getFieldValue(row, ["Lead Status* (new/followup/qualified/hot/converted/lost)", "Lead Status", "LeadStatus", "leadStatus"])),
          ["new", "followup", "qualified", "hot", "converted", "lost"],
          "new"
        ) as any,
        leadCreatedBy: cleanValue(row["Lead Created By"] || row["LeadCreatedBy"] || row.leadCreatedBy),
        additionalNotes: cleanValue(row["Additional Notes"] || row["AdditionalNotes"] || row.additionalNotes)
      };
    } catch (error) {
      console.error(`Error transforming row ${rowNumber}:`, error);
      // Return a default lead instead of throwing error
      return {
        name: `Lead ${rowNumber}`,
        phoneNumber: "N/A",
        email: undefined,
        dateOfBirth: undefined,
        city: undefined,
        state: undefined,
        country: undefined,
        pincode: undefined,
        companyName: undefined,
        designation: undefined,
        customerCategory: "potential" as "existing" | "potential",
        lastContactedDate: undefined,
        lastContactedBy: undefined,
        nextFollowupDate: undefined,
        customerInterestedIn: undefined,
        preferredCommunicationChannel: "email" as any,
        customCommunicationChannel: undefined,
        leadSource: "website" as any,
        customLeadSource: undefined,
        customReferralSource: undefined,
        customGeneratedBy: undefined,
        leadStatus: "new" as any,
        leadCreatedBy: undefined,
        additionalNotes: undefined
      };
    }
  };

  return (
    <Dialog open={isOpen} onOpenChange={setIsOpen}>
      <DialogTrigger asChild>
        <Button className="btn-impressive-secondary" data-testid="button-import-leads">
          <Download className="mr-2 h-4 w-4 icon" />
          Import Leads
        </Button>
      </DialogTrigger>
      <DialogContent className="max-w-md">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <Upload className="h-5 w-5" />
            Import Leads
          </DialogTitle>
        </DialogHeader>

        <div className="space-y-6">
          {/* Template Download */}
          <div>
            <div className="flex items-center gap-2 mb-3">
              <FileText className="h-4 w-4 text-blue-600" />
              <h4 className="text-sm font-medium">Download Template</h4>
            </div>
            <p className="text-xs text-gray-600 mb-3">
              Download our CSV template with all required fields to ensure proper formatting.
            </p>
            <Button 
              onClick={handleDownloadTemplate}
              variant="outline"
              className="w-full"
              data-testid="button-download-template"
            >
              <Download className="mr-2 h-4 w-4" />
              Download Template (CSV)
            </Button>
          </div>

          <Separator />

          {/* File Upload */}
          <div>
            <div className="flex items-center gap-2 mb-3">
              <Upload className="h-4 w-4 text-green-600" />
              <h4 className="text-sm font-medium">Upload File</h4>
            </div>
            <p className="text-xs text-gray-600 mb-3">
              Upload your CSV file with lead data. Make sure to follow the template format.
            </p>
            <Button 
              onClick={handleUploadFile}
              disabled={isImporting}
              className="w-full"
              data-testid="button-upload-file"
            >
              {isImporting ? (
                <>
                  <ButtonLoader size={16} color="#ffffff" />
                  <span className="ml-2">Importing...</span>
                </>
              ) : (
                <>
                  <Upload className="mr-2 h-4 w-4" />
                  Choose File & Upload
                </>
              )}
            </Button>
          </div>

          <Separator />

          {/* Import Results */}
          {importResults && (
            <>
              <Separator />
              <div>
                <div className="flex items-center gap-2 mb-3">
                  {importResults.results.successful > 0 ? (
                    <CheckCircle className="h-4 w-4 text-green-600" />
                  ) : (
                    <XCircle className="h-4 w-4 text-red-600" />
                  )}
                  <h4 className="text-sm font-medium">Import Results</h4>
                </div>
                
                <div className="space-y-2 text-xs">
                  <div className="flex justify-between">
                    <span>Total Records:</span>
                    <span className="font-medium">{importResults.results.total}</span>
                  </div>
                  <div className="flex justify-between text-green-600">
                    <span>Successfully Imported:</span>
                    <span className="font-medium">{importResults.results.successful}</span>
                  </div>
                  {importResults.results.failed > 0 && (
                    <div className="flex justify-between text-red-600">
                      <span>Failed:</span>
                      <span className="font-medium">{importResults.results.failed}</span>
                    </div>
                  )}
                </div>

                {/* Error Details */}
                {importResults.results.errors && importResults.results.errors.length > 0 && (
                  <div className="mt-3">
                    <h5 className="text-xs font-medium text-red-600 mb-2">Error Details:</h5>
                    <div className="max-h-32 overflow-y-auto space-y-1">
                      {importResults.results.errors.slice(0, 5).map((error: any, index: number) => (
                        <div key={index} className="text-xs text-red-600 bg-red-50 p-2 rounded">
                          <strong>Row {error.row}:</strong> {error.error}
                        </div>
                      ))}
                      {importResults.results.errors.length > 5 && (
                        <div className="text-xs text-gray-500">
                          ... and {importResults.results.errors.length - 5} more errors
                        </div>
                      )}
                    </div>
                  </div>
                )}
              </div>
            </>
          )}

          {/* Instructions */}
          <Alert>
            <AlertCircle className="h-4 w-4" />
            <AlertDescription className="text-xs">
              <strong>Important:</strong> Fields marked with * are required. 
              Make sure your file follows the template format for successful import.
            </AlertDescription>
          </Alert>

          {/* Action Buttons */}
          <div className="flex justify-end gap-2">
            {importResults && (
              <Button 
                variant="outline"
                onClick={() => {
                  setImportResults(null);
                  setIsOpen(false);
                }}
              >
                Close
              </Button>
            )}
            <Button 
              variant="outline"
              onClick={() => setIsOpen(false)}
              data-testid="button-cancel-import"
            >
              Cancel
            </Button>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
} 